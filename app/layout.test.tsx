import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import RootLayout, { metadata } from './layout';

describe('RootLayout', () => {
  describe('Component Rendering', () => {
    it('should render children correctly', () => {
      render(
        <RootLayout>
          <div data-testid="test-child">Test Content</div>
        </RootLayout>
      );

      expect(screen.getByTestId('test-child')).toBeInTheDocument();
      expect(screen.getByText('Test Content')).toBeInTheDocument();
    });

    it('should render html element with lang attribute', () => {
      const { container } = render(
        <RootLayout>
          <div>Content</div>
        </RootLayout>
      );

      const htmlElement = container.querySelector('html');
      expect(htmlElement).toBeInTheDocument();
      expect(htmlElement).toHaveAttribute('lang', 'en');
    });

    it('should render body element with font classes', () => {
      const { container } = render(
        <RootLayout>
          <div>Content</div>
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement).toBeInTheDocument();
      expect(bodyElement?.className).toContain('--font-geist-sans');
      expect(bodyElement?.className).toContain('--font-geist-mono');
      expect(bodyElement?.className).toContain('antialiased');
    });

    it('should apply antialiased class for font smoothing', () => {
      const { container } = render(
        <RootLayout>
          <div>Content</div>
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement?.className).toMatch(/antialiased/);
    });
  });

  describe('Multiple Children', () => {
    it('should render multiple children correctly', () => {
      render(
        <RootLayout>
          <div data-testid="child-1">First Child</div>
          <div data-testid="child-2">Second Child</div>
          <div data-testid="child-3">Third Child</div>
        </RootLayout>
      );

      expect(screen.getByTestId('child-1')).toBeInTheDocument();
      expect(screen.getByTestId('child-2')).toBeInTheDocument();
      expect(screen.getByTestId('child-3')).toBeInTheDocument();
    });

    it('should handle nested children', () => {
      render(
        <RootLayout>
          <div>
            <div data-testid="nested-child">
              <span>Deeply nested content</span>
            </div>
          </div>
        </RootLayout>
      );

      expect(screen.getByTestId('nested-child')).toBeInTheDocument();
      expect(screen.getByText('Deeply nested content')).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty children', () => {
      const { container } = render(
        <RootLayout>
          <></>
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement).toBeInTheDocument();
    });

    it('should handle null children gracefully', () => {
      const { container } = render(
        <RootLayout>
          {null as any}
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement).toBeInTheDocument();
    });

    it('should handle undefined children gracefully', () => {
      const { container } = render(
        <RootLayout>
          {undefined as any}
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement).toBeInTheDocument();
    });

    it('should render with fragments as children', () => {
      render(
        <RootLayout>
          <>
            <div>Fragment Child 1</div>
            <div>Fragment Child 2</div>
          </>
        </RootLayout>
      );

      expect(screen.getByText('Fragment Child 1')).toBeInTheDocument();
      expect(screen.getByText('Fragment Child 2')).toBeInTheDocument();
    });
  });

  describe('Metadata', () => {
    it('should export correct metadata object', () => {
      expect(metadata).toBeDefined();
      expect(metadata.title).toBe('Create Next App');
      expect(metadata.description).toBe('Generated by create next app');
    });

    it('should have string type for title', () => {
      expect(typeof metadata.title).toBe('string');
    });

    it('should have string type for description', () => {
      expect(typeof metadata.description).toBe('string');
    });

    it('should not have empty title', () => {
      expect(metadata.title).not.toBe('');
      expect(metadata.title).toBeTruthy();
    });

    it('should not have empty description', () => {
      expect(metadata.description).not.toBe('');
      expect(metadata.description).toBeTruthy();
    });
  });

  describe('Accessibility', () => {
    it('should have proper document structure', () => {
      const { container } = render(
        <RootLayout>
          <main>Main Content</main>
        </RootLayout>
      );

      const htmlElement = container.querySelector('html');
      const bodyElement = container.querySelector('body');
      const mainElement = container.querySelector('main');

      expect(htmlElement).toBeInTheDocument();
      expect(bodyElement).toBeInTheDocument();
      expect(mainElement).toBeInTheDocument();
    });

    it('should maintain semantic HTML structure', () => {
      render(
        <RootLayout>
          <header>Header</header>
          <main>Main</main>
          <footer>Footer</footer>
        </RootLayout>
      );

      expect(screen.getByText('Header')).toBeInTheDocument();
      expect(screen.getByText('Main')).toBeInTheDocument();
      expect(screen.getByText('Footer')).toBeInTheDocument();
    });
  });

  describe('Font Loading', () => {
    it('should include both Geist font variables', () => {
      const { container } = render(
        <RootLayout>
          <div>Content</div>
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      const className = bodyElement?.className || '';

      expect(className).toContain('--font-geist-sans');
      expect(className).toContain('--font-geist-mono');
    });
  });

  describe('Styling', () => {
    it('should apply all required CSS classes', () => {
      const { container } = render(
        <RootLayout>
          <div>Content</div>
        </RootLayout>
      );

      const bodyElement = container.querySelector('body');
      expect(bodyElement?.className).toBeTruthy();
      expect(bodyElement?.className.split(' ').length).toBeGreaterThan(0);
    });
  });
});